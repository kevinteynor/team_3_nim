Group 3 - Learning Nim Game Change Log

12:00 PM 4/15/2013 - Justin Ward

Start:

Added NimLogic.cs as a public static class for containing all methods which check and use Logic specific to the game of Nim.
This class will be an example of Logical Cohesion, storing methods together that are related logically. Methods will
be extracted from Game.cs and BoardState.cs into this class, where logical.

:End

12:12 PM 4/15/2013 - Justin Ward

Start:


//Moved to NimLogic.cs as IsMoveValid(BoardState bs1, BoardState bs2);
//public bool checkIfValid(BoardState change)
//{
//    if (this.RowACount > change.RowACount && (change.RowBCount == this.RowBCount && change.RowCCount == this.RowCCount))
//        return true;
//    if (this.RowBCount > change.RowBCount && (change.RowACount == this.RowACount && change.RowCCount == this.RowCCount))
//        return true;
//    if (this.RowCCount > change.RowCCount && (change.RowACount == this.RowACount && change.RowBCount == this.RowBCount))
//        return true;
//
//    return false;
//}


Moved checkIfValid from BoardState into NimLogic.cs as IsMoveValid. This move was made to make the intentions of the method
more obvious, and to place it where it logically belongs. A BoardState object should not perform a check for a valid
move from one state to another, it is merely a container for state information, not the rules of the game.

I changed the method to be static as it is contained within the static class NimLogic. This will allow this simple check,
which is likely to be used frequently, to be accessed throughout the program.

/// <summary>
/// In Nim a valid move is defined as removing from 1 to all tokens from 1 row,
/// this methods verifies that the difference between the first parameter
/// and the second constitutes a valid move.
/// </summary>
/// <param name="currentState">The current state of the game board</param>
/// <param name="proposedState">The state which an AI or Player's move will result in</param>
/// <returns>If the move the AI or Player is making is valid</returns>
public static bool IsMoveValid(BoardState currentState, BoardState proposedState)
	{
            if (currentState.RowACount > proposedState.RowACount &&
                proposedState.RowACount >= 0)
            {
                if (currentState.RowBCount == proposedState.RowBCount &&
                    currentState.RowCCount == proposedState.RowCCount) return true;
            }

            if (currentState.RowBCount > proposedState.RowBCount &&
                proposedState.RowBCount >= 0)
            {
                if (currentState.RowACount == proposedState.RowACount &&
                    currentState.RowCCount == proposedState.RowCCount) return true;
            }

            if (currentState.RowCCount > proposedState.RowCCount &&
                proposedState.RowCCount >= 0)
            {
                if (currentState.RowACount == proposedState.RowACount &&
                    currentState.RowBCount == proposedState.RowBCount) return true;
   	    }

   		return false;
	}

:End

12:51PM 4/15/2013 - Justin Ward

Start:

//Moved to NimLogic as ChooseRandomMoveWithinGameConstraints(BoardState currentBoard)
//private BoardState chooseRandomMove()
//{
//    BoardState newState = new BoardState(currentBoard);
//    bool removed = false;
//    do
//    {
//        int row = random.Next(0, 3);
//        if (row == 0)
//        {
//            if (newState.RowACount <= 0)
//                continue;
//            newState.RowACount -= random.Next(1, newState.RowACount + 1);
//            removed = true;
//        }
//        else if (row == 1)
//        {
//            if (newState.RowBCount <= 0)
//                continue;
//            newState.RowBCount -= random.Next(1, newState.RowBCount + 1);
//            removed = true;
//        }
//        else if (row == 2)
//        {
//            if (newState.RowCCount <= 0)
//                continue;
//            newState.RowCCount -= random.Next(1, newState.RowCCount + 1);
//            removed = true;
//        }
//    } while (!removed);
//    return newState;
//}

Moved chooseRandomMove from Game.cs to NimLogic.cs as ChooseRandomMoveWithinGameConstaints.
This is a more logical location for this method.This method must apply the rules of Nim and therefore 
logically belongs in NimLogic.cs. Another viable location for this method would be within an AI class,
as it is likely that nothing else would need to Choose a ran

/// <summary>
/// Returns a random move that is possible from the currentBoard and valid
/// according to the rules of Nim.
/// </summary>
/// <param name="currentBoard">The state of the current Game Board</param>
/// <returns>A new randomly chosen BoardState</returns>
public static BoardState ChooseRandomMoveWithinGameConstraints(BoardState currentBoard)
    {
        BoardState validRandomMove = new BoardState(currentBoard);
        Random randomGen = new Random();

        do
        {
            int randomRow = randomGen.Next(0, 3);

            if (randomRow == 0)
            {
                if (validRandomMove.RowACount <= 0) continue;
                else validRandomMove.RowACount -= randomGen.Next(1, validRandomMove.RowACount + 1);
            }
            else if (randomRow == 1)
            {
                if (validRandomMove.RowBCount <= 0) continue;
                else validRandomMove.RowBCount -= randomGen.Next(1, validRandomMove.RowBCount + 1);
            }
            else if (randomRow == 2)
            {
                if (validRandomMove.RowCCount <= 0) continue;
                else validRandomMove.RowCCount -= randomGen.Next(1, validRandomMove.RowCCount + 1);
            }
        }
        while (validRandomMove.Equals(currentBoard) || !NimLogic.IsMoveValid(currentBoard, validRandomMove));

        return validRandomMove;
    }

:End

1:20PM 4/15/2013 - Justin Ward

Start: 

I forgot modify Game.cs to use ChooseRandomMoveWithinGameConstraints rather than chooseRandomMove(), due to this
the previous build is broken.

:End

1:30PM 4/15/2013 - Justin Ward

Start:

        //Replaced by NimLogic.EveryPossibleBoardState()
        //public static BoardState[] GetAllPossibleStates()
        //{
        //    BoardState[] states = new BoardState[192];
        //    int i = 0;

        //    for (int rA = 0; rA <= 3; rA++)
        //    {
        //        for (int rB = 0; rB <= 5; rB++)
        //        {
        //            for (int rC = 0; rC <= 7; rC++)
        //            {
        //                BoardState b = new BoardState();
        //                b.Frequency = 0;
        //                b.StateValue = 0;
        //                b.RowACount = rA;
        //                b.RowBCount = rB;
        //                b.RowCCount = rC;

        //                states[i] = new BoardState(b);
        //                i++;
        //            }
        //        }
        //    }

        //    return states;
        //}

I moved GetAllPossibleStates from BoardState.cs to NimLogic.cs. I believe this is a better place for this method
as it is already static, and it doesn't feel right being a member of BoardState. I also replaced the return
type of BoardState[] with an IEnumerable<BoardState>. This is in response to the Computer Science base rule
of favoring Iterators to Lists. This way we can use this method in LINQ queries to find a specific state
or for it's original use of compiling a list of all BoardStates.

        /// <summary>
        /// Used to provide a list of all possible BoardStates.
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<BoardState> EveryPossibleBoardState()
        {
            for (int rowA = 0; rowA <= 3; rowA++)
            {
                for (int rowB = 0; rowB <= 5; rowB++)
                {
                    for (int rowC = 0; rowC <= 7; rowC++)
                    {
                        BoardState b = new BoardState();
                        b.Frequency = 0;
                        b.StateValue = 0;
                        b.RowACount = rowA;
                        b.RowBCount = rowB;
                        b.RowCCount = rowC;

                        yield return b;
                    }
                }
            }
        }

:End